
writeln " *******************************************************************";
writeln " *        Модель секторной КЕШ памяти со сквозной записью          *";
writeln " *******************************************************************";

{**************************** Описание типов *********************************}

    { переменные используемые в программе моделирования }
var storeAddress, { временное хранение адреса }
    iOperation,   { номер текущей операции с памятью }
    op_code,      { код текущей операции }
    data,         { данные }
    replace,      { номер замещаемого сегмента на данном шаге }
    numberOfSegment, { номер сектора, содержащего необходимый сегмент }

    { типы используемые п/п }
    choice,  { номер варианта }
    i, j;    { вспомогательные переменные }

mem op[32][8];         { оперативная память: 32 слова по 8 бит }
mem bp[16][10];        { буферная память: 16 слов по 10 бит }
mem opAddresses[3][5]; { память исполнительных адресов, содержит исполнительные адреса }
mem inputs[3][8];      { числа для записи, содержит числа записываемые в память }
mem operationCodes[3][1];  { коды операций для каждого шага: 0-запись, 1-чтение }
mem segmentsInBP[2][2];    { регистры номеров присутствующих сегментов }
mem replaceSegments[3][2]; { номерa сегментoв вытесняемых из БП при замещении }

struct iadr[5]  { адрес ячейки ОП 32 слова }
       blok[3], { номер блока 8 шт. }
       seg [2]; { номер сегмента 4 шт.}

struct bpadr[4] { адрес ячейки БП 16 слов }
       blok[3], { номер блока 8 шт. }
       sect[1]; { номер сектора 2 шт. }

struct buf_reg[10] { структура слова буферной памяти, в эту структуру
считывается слово БП при любой обработке, что позволяет различать в
нём биты присутствия, изменения и собственно данные }
       data[8],   { данные }
	   none[1],
       exists[1]; { бит наличия }

    { переменные используемые в подпрограммах }
struct subiadr[5]    blok[3], seg[2];
struct subbpadr[4]   blok[3], sect[1];
struct subbuf_reg[10] data[8], none[1], exists[1];

{**************************** Начало программы *******************************}

choice:=7;
gosub variant;     { задание начальных значений всех переменных }

for iOperation := 0 to 2;
  writeln;
  writeln " ********************** Операция №", $d1 iOperation + 1,
    " ********************************";

    { Считывание данных из массивов в переменные для текущей операции }
  replace := replaceSegments[iOperation];
  op_code := operationCodes [iOperation];
  iadr    := opAddresses    [iOperation];
  data    := inputs         [iOperation];
  
  if op_code = 0 then write "Запись значения ", $d3 data, " в ОП по адресу ";
  if op_code = 1 then write "Чтение значения из ОП по адресу ";
  writeln $d2 iadr, " (", $h1 iadr.seg, ":", $h1 iadr.blok, ")";

    { Поиск наличия сегмента в БП }
  numberOfSegment := 255;
  if segmentsInBP[0] = iadr.seg then numberOfSegment := 0;
  if segmentsInBP[1] = iadr.seg then numberOfSegment := 1;
  if numberOfSegment <> 255 then goto P_GetBlock; { если сегмент присутствует в БП... }

    { Если сегмент отсутствует в БП }
  writeln "Сегмент ", $d2 iadr.seg, " отсутствует в буферной памяти";
  writeln "Вытеснение сегмента ", $d2 replace;
  if segmentsInBP[0]=replace then numberOfSegment:=0;
  if segmentsInBP[1]=replace then numberOfSegment:=1;

    { Вытеснение сегмента из БП }
  bpadr.sect := numberOfSegment;
  for i := 0 to 7;
    bpadr.blok := i;
    buf_reg := bp[bpadr];
    buf_reg.exists := 0;
    bp[bpadr] := buf_reg;
  next;
  segmentsInBP[numberOfSegment] := iadr.seg;

P_GetBlock:
  bpadr.blok := iadr.blok; { вычисление адреса блока БП по адресу ОП }
  bpadr.sect := numberOfSegment;
  buf_reg := bp[bpadr]; { чтение блока из БП в буферный регистр }
  if buf_reg.exists = 1 then goto P_ProcessOperation; { блок присутствует }

    { Если блок отсутствует в БП }
  writeln "Блок ", $d2 iadr.blok, " сегмента ", $d2 iadr.seg,
    " отсутствует в буферной памяти";
  buf_reg.data:=op[iadr];
  buf_reg.exists:=1;
  writeln "Получение блока из оперативной памяти (данные: ",$d3 buf_reg.data,")";

P_ProcessOperation: { выполнение операции по коду }
  if op_code = 1 then goto P_ProcessRead;

P_ProcessWrite:
  buf_reg.data := data;
  op[iadr] := data;
  writeln "В БП и ОП записаны данные: ", $d3 data;
  goto P_ProcessEnd;

P_ProcessRead:
  data := buf_reg.data;
  writeln "Из БП прочитаны данные: ", $d3 data;

P_ProcessEnd:
  bp[bpadr] := buf_reg; { запись из регистра в буферную память }
  gosub print_bp;   { печать содержимого БП }
  gosub print_op;   { печать содержимого ОП }
{ pause; }
next;
end;

{**************************** Конец программы ********************************}

{****************************** Подпрограммы *********************************}

{ p/p zadanie varianta ,ispol'zuet p/p first,second,third }

variant:

{ zadanie ishodnih dannih po variantam }
if choice=0 then read "Введите номер варианта: ",choice;

if choice<=5 then gosub first;
if ((choice>5) and (choice<=10)) then gosub second;
if choice>10 then gosub third;

return; { variant }

{ p/p pervii variant }

first:

{ prisvaivanie nacal'nih znacenii aceikam OP }

for i:=0 to 31;
    op[i]:=(choice+2)*2+i-2;
next;

{ prisvaivanie nacal'nih znacenii aceikam BP }

for i:=0 to 15;
   buf_reg.data:=(choice+2)*2+i-2;
   buf_reg.ch_bit:=0;
   buf_reg.exists:=1;
   bp[i]:=buf_reg;
next;

for i:=2 to 5;
   buf_reg.data:=choice+i-2;
   buf_reg.ch_bit:=0;
   buf_reg.exists:=0;
   bp[i]:=buf_reg;
next;

{ naznacenie ispolnitel'nih adresov }

opAddresses[0]:=4;
opAddresses[1]:=29;
opAddresses[2]:=15;

{ zadanie cicel dla zapisi }

for i:=0 to 2;
   inputs[i]:=i+8;
next;

{ KOPi }

operationCodes[0]:=0;
operationCodes[1]:=1;
operationCodes[2]:=0;

{ nomera priutstvuysih segmentov }

segmentsInBP[0]:=0;
segmentsInBP[1]:=1;

{ nomera zamesaemih segmentov }

replaceSegments[0]:=0;
replaceSegments[1]:=0;
replaceSegments[2]:=0;

gosub print_bp;   { pecat' soderjimogo BP }
pause;
gosub print_op;   { pecat' soderjimogo OP }
gosub print; { pecat' zapisivaemih cisel i zamesaemih segmentov }
pause;

return; { first }

{ p/p vtoroi variant }

second:

{ prisvaivanie nacal'nih znacenii aceikam OP }

for i:=0 to 31;
    op[i]:=(choice+2)*2+i-8;
next;

{ prisvaivanie nacal'nih znacenii aceikam BP }

for i:=0 to 15;
   buf_reg.data:=(choice+2)*2+i;
   buf_reg.exists:=1;
   bp[i]:=buf_reg;
next;

for i:=0 to 3;
   buf_reg.data:=choice-4;
   buf_reg.exists:=0;
   bp[i]:=buf_reg;
next;

{ naznacenie icpolnitel'nih adresov }

opAddresses[0]:=10;
opAddresses[1]:=30;
opAddresses[2]:=19;

{ zadanie cicel dla zapisi }

for i:=0 to 2;
   inputs[i]:=i+12;
next;

{ KOPi }

operationCodes[0]:=1;
operationCodes[1]:=0;
operationCodes[2]:=1;

{ nomera prisutstvuysih segmentov }

segmentsInBP[0]:=1;
segmentsInBP[1]:=2;

{ nomera zamesaemih segmentov }

replaceSegments[0]:=0;
replaceSegments[1]:=1;
replaceSegments[2]:=0;

gosub print_bp;   { pecat' soderjimogo BP }
gosub print_op;   { pecat' soderjimogo OP }
gosub print; { pecat' zapisivaemih cisel i zamesaemih segmentov }

return; { second }

{ p/p tretii variant }

third:

{ prisvaivanie nacal'nih znacenii aceikam OP }

for i:=0 to 31;
    op[i]:=(choice+2)/2+i+5;
next;

{ prisvaivanie nacal'nih znacenii aceikam BP }

for i:=0 to 15;
   buf_reg.data:=(choice+2)/2+i+21;
   buf_reg.exists:=1;
   bp[i]:=buf_reg;
next;

for i:=4 to 7;
   buf_reg.data:=choice-7;
   buf_reg.exists:=0;
   bp[i]:=buf_reg;
next;

{ naznacenie ispolnitel'nih adresov }

opAddresses[0]:=21;
opAddresses[1]:=8;
opAddresses[2]:=24;

{ zadanie cisel dla zapisi }

for i:=0 to 2;
   inputs[i]:=i+23;
next;

{ KOPi }

operationCodes[0]:=1;
operationCodes[1]:=1;
operationCodes[2]:=0;

{ nomera prisutstvuysih segmentov }

segmentsInBP[0]:=2;
segmentsInBP[1]:=3;

{ nomera zamesaemih segmentov }

replaceSegments[0]:=0;
replaceSegments[1]:=2;
replaceSegments[2]:=0;

gosub print_bp;   { pecat' soderjimogo BP }
pause;
gosub print_op;   { pecat' soderjimogo OP }
gosub print; { pecat' zapisivaemih cisel i zamesaemih segmentov }
pause;

return; { third }

{ p/p pecati soderjimogo bufernoi pamati }

print_bp:
   writeln;
   writeln "Содержимое буферной памяти:";
   writeln " ____________________________________";
   writeln "|      |   Сектор 0   |   Сектор 1   |";
   writeln "|_Блок_|_Прис._Данные_|_Прис._Данные_|";
   for i:=0 to 7;
      write "| ", $d2 i, "   ";
      subbpadr.sect:=0;
      subbpadr.blok:=i;
      subbuf_reg:=bp[subbpadr];
      gosub print_br;
      subbpadr.sect:=1;
      subbuf_reg:=bp[subbpadr];
      gosub print_br;
      writeln "|";
   next;
   writeln "--------------------------------------";
   writeln "Содержимое РНПС:";
   writeln "  сектор 0: сегмент", $d2 segmentsInBP[0];
   writeln "  сектор 1: сегмент", $d2 segmentsInBP[1];
return; { print_bp }

{ p/p pecati soderjimogo bufernogo registra }

print_br:
   write "|   ", $b1 subbuf_reg.exists;
   write "   ", $d4 subbuf_reg.data, "   ";
return; { print_br }

{ p/p pecati soderjimogo operativnoi pamati }

print_op:
   writeln;
   writeln "Содержимое оперативной памяти:";
   writeln " _____________________________________________";
   writeln "|___Блок_#__|___0___1___2___3___4___5___6___7_|";
   for i:=0 to 3;
      write "|Сегмент #",$d1 i," |";
      subiadr.seg:=i;
      for j:=0 to 7;
         subiadr.blok:=j;
         write $d4 op[subiadr];
      next;
      writeln " |";
   next;
   writeln "-----------------------------------------------";

return; { print_op }

{ p/p pecati zapisivaemih cisel i zamesaemih segmentov }

print:
   writeln;
   writeln " _____________________________________________";
   writeln "| № обращ. | Операция | Числа для | № вытесн. |";
   writeln "|__________|__________|___записи__|__сегмента_|";
   for i := 0 to 2;
      write "|     ", $d1 i , "    |";
      if operationCodes[i] = 0 then write "  запись  |";
      if operationCodes[i] = 1 then write "  чтение  |";
      writeln $d7 inputs[i], "    |", $d6 replaceSegments[i], "     |";
   next;
   writeln "-----------------------------------------------";
return; { print }
